{	
	"CPTemplate": {
	"prefix": "goat",
	"body": [
		"#include <bits/stdc++.h>",
		"using namespace std;",
		"",
		"typedef long long ll;",
		"typedef vector<int> vi;",
		"typedef vector<ll> vll;",
		"typedef vector<char> vc;",
		"typedef vector<bool> vb;",
		"typedef vector<string> vs;",
		"typedef vector<vi> vvi;",
		"typedef vector<vll> vvll;",
		"typedef vector<vc> vvc;",
		"typedef vector<vb> vvb;",
		"typedef vector<vs> vvs;",
		"",
		"#ifndef ONLINE_JUDGE",
		"    #define sep() cout<<\"------------------------------------\"<<endl;",
		"    #define debug1(x) cout<<#x<<\" =\"<<x<<endl;",
		"    #define debug2(x) do{\\",
		"        cout<<#x<<\" :\\n\";\\",
		"        prettyprint(x);\\",
		"    } while(0)",
		"#else",
		"    #define sep()",
		"    #define debug1(x)",
		"    #define debug2(x)",
		"#endif",
		"",
		"// vector",
		"template<typename T> struct is_vector : false_type {};",
		"template<typename T, typename Alloc> struct is_vector<vector<T,Alloc>> : true_type {};",
		"",
		"// map",
		"template<typename T> struct is_map : false_type {};",
		"template<typename K, typename V, typename Comp, typename Alloc>",
		"struct is_map<map<K,V,Comp,Alloc>> : true_type {};",
		"template<typename K, typename V, typename Hash, typename Eq, typename Alloc>",
		"struct is_map<unordered_map<K,V,Hash,Eq,Alloc>> : true_type {};",
		"",
		"// multimap",
		"template<typename T> struct is_multimap : false_type {};",
		"template<typename K, typename V, typename Comp, typename Alloc>",
		"struct is_multimap<multimap<K,V,Comp,Alloc>> : true_type {};",
		"template<typename K, typename V, typename Hash, typename Eq, typename Alloc>",
		"struct is_multimap<unordered_multimap<K,V,Hash,Eq,Alloc>> : true_type {};",
		"",
		"// set",
		"template<typename T> struct is_set : false_type {};",
		"template<typename K, typename Comp, typename Alloc>",
		"struct is_set<set<K,Comp,Alloc>> : true_type {};",
		"template<typename K, typename Hash, typename Eq, typename Alloc>",
		"struct is_set<unordered_set<K,Hash,Eq,Alloc>> : true_type {};",
		"",
		"// multiset",
		"template<typename T> struct is_multiset : false_type {};",
		"template<typename K, typename Comp, typename Alloc>",
		"struct is_multiset<multiset<K,Comp,Alloc>> : true_type {};",
		"template<typename K, typename Hash, typename Eq, typename Alloc>",
		"struct is_multiset<unordered_multiset<K,Hash,Eq,Alloc>> : true_type {};",
		"",
		"template<typename A, typename B>",
		"ostream& operator<<(ostream& os, const pair<A,B>& p) {",
		"    os << \"(\" << p.first << \", \" << p.second << \")\";",
		"    return os;",
		"}",
		"",
		"template<typename T>",
		"string as_string(const T& x) {",
		"    stringstream ss;",
		"    ss << x;",
		"    return ss.str();",
		"}",
		"",
		"template<typename T>",
		"void prettyprint_vector(const vector<T>& x) {",
		"    if constexpr (is_vector<T>::value) {",
		"        // Recursive case: vector of vectors (2D, 3D, â€¦)",
		"        int n = (int)x.size();",
		"        if (n == 0) {",
		"            cout << \"(empty)\\n\";",
		"            return;",
		"        }",
		"",
		"        int rowWidth = (n <= 1 ? 1 : (int)log10((long double)(n-1)) + 1);",
		"",
		"        // find max column size (jagged safe)",
		"        int m = 0;",
		"        for (auto &row : x) m = max(m, (int)row.size());",
		"",
		"        // compute column widths",
		"        vector<int> colWidth(m, 1);",
		"        for (auto &row : x) {",
		"            for (int j = 0; j < (int)row.size(); j++) {",
		"                stringstream ss;",
		"                ss << row[j];",
		"                colWidth[j] = max(colWidth[j], (int)ss.str().size());",
		"            }",
		"        }",
		"",
		"        // print column indices",
		"        cout << string(rowWidth + 2, ' ');",
		"        for (int j = 0; j < m; j++) {",
		"            int idxWidth = (j == 0 ? 1 : (int)log10((long double)j) + 1);",
		"            colWidth[j] = max(colWidth[j], idxWidth);",
		"            cout << setw(colWidth[j] + 1) << j;",
		"        }",
		"        cout << \"\\n\";",
		"",
		"        // print each row",
		"        for (int i = 0; i < n; i++) {",
		"            cout << setw(rowWidth) << i << \" :\";",
		"            for (int j = 0; j < m; j++) {",
		"                if (j < (int)x[i].size()) {",
		"                    stringstream ss;",
		"                    ss << x[i][j];",
		"                    cout << setw(colWidth[j] + 1) << ss.str();",
		"                } else {",
		"                    cout << setw(colWidth[j] + 1) << \" \"; // blank for jagged",
		"                }",
		"            }",
		"            cout << \"\\n\";",
		"        }",
		"    } else {",
		"        int n = (int)x.size();",
		"        if (n == 0) { cout << \"(empty)\\n\"; return; }",
		"",
		"        vector<int> widths(n);",
		"        for (int i = 0; i < n; i++) {",
		"            string s = as_string(x[i]);",
		"            int valWidth = (int)s.size();",
		"            int idxWidth = (i == 0 ? 1 : (int)log10(i)+1);",
		"            widths[i] = max(valWidth, idxWidth);",
		"        }",
		"",
		"        cout << \"idx:\";",
		"        for (int i = 0; i < n; i++)",
		"            cout << setw(widths[i]+1) << i;",
		"        cout << \"\\nval:\";",
		"        for (int i = 0; i < n; i++)",
		"            cout << setw(widths[i]+1) << as_string(x[i]);",
		"        cout << \"\\n\";",
		"    }",
		"}",
		"",
		"template<typename T>",
		"void prettyprint(const T& container) {",
		"    if constexpr (is_vector<T>::value) {",
		"        prettyprint_vector(container);",
		"    }",
		"    else if constexpr (is_map<T>::value || is_multimap<T>::value) {",
		"        vector<pair<typename T::key_type, typename T::mapped_type>> v(container.begin(), container.end());",
		"        prettyprint_vector(v);",
		"    }",
		"    else if constexpr (is_set<T>::value || is_multiset<T>::value) {",
		"        vector<typename T::value_type> v(container.begin(), container.end());",
		"        prettyprint_vector(v);",
		"    }",
		"    else {",
		"        static_assert(!sizeof(T*), \"prettyprint: unsupported container\");",
		"    }",
		"}",
		"",
		"template<typename... Vecs>",
		"void v1d(int startIdx, int finalIdx, Vecs&... vecs) {",
		"    for (int i = startIdx; i <= finalIdx; i++) {",
		"        (cin >> ... >> vecs[i]);",
		"    }",
		"}",
		"",
		"#define all(x) (x).begin(), (x).end()",
		"#define setmin(a,b) a = min(a, (b))",
		"#define setmax(a,b) a = max(a, (b))",
		"",
		"void yes(){cout<<\"YES\"<<endl;}",
		"void no(){cout<<\"NO\"<<endl;}",
		"void alice(){cout<<\"Alice\"<<endl;}",
		"void bob(){cout<<\"Bob\"<<endl;}",
		"",
		"int main(){",
		"    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);",
		"    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());",
		"    auto genRand = [&]()->ll{",
		"        return (ll)rng();",
		"    };",
		"",
		"    bool tc = true;",
		"",
		"    int t=1; ",
		"    if(tc) cin>>t;",
		"",
		"    // global preprocessing here",
		"    while(t--){",
		"        $1",
		"    }",
		"}",
		""
	],
	"description": "CPTemplate"
	},
	"DisjointSetUnion": {
		"prefix": "cp_dsu",
		"body": [
		"class dsu { // dsu",
		"    public:",
		"    vector<int> rank, size, parent;",
		"",
		"    dsu(int sz){",
		"        rank.resize(sz+1); size.resize(sz+1); parent.resize(sz+1);",
		"        for(int i=0;i<=sz;i++) { parent[i]=i; size[i]=1; rank[i]=0; }",
		"    }",
		"    int find(int node){",
		"        if (node==parent[node]) return node;",
		"        return parent[node] = find(parent[node]);",
		"    }",
		"    void unionByRank(int u, int v){",
		"        // Node with greater rank becomes parent",
		"        int ulp_u = find(u); int ulp_v = find(v); if(ulp_u==ulp_v) return;",
		"        if (rank[ulp_u]==rank[ulp_v]) {parent[ulp_v] = ulp_u; rank[ulp_u]++;}",
		"        else if(rank[ulp_u]<rank[ulp_v]) parent[ulp_u] = ulp_v;",
		"        else parent[ulp_v] = ulp_u; // rank[ulp_u]>rank[ulp_v]",
		"    }",
		"    void unionBySize(int u, int v){",
		"        // Bigger size node becomes parent",
		"        int ulp_u = find(u); int ulp_v = find(v); if(ulp_u==ulp_v) return;",
		"        if (size[ulp_u]<size[ulp_v]) { parent[ulp_u] = ulp_v; size[ulp_v]+=size[ulp_u]; }",
		"        else { parent[ulp_v] = ulp_u; size[ulp_u]+=size[ulp_v]; }",
		"    }",
		"    void unite(int u, int v){",
		"        unionBySize(u,v);",
		"    }",
		"};"
		],
		"description": "CP_DisjointSetUnion"
	},
	"SGT": {
		"prefix": "cp_SGT",
		"body": [
		"class SGTree{ // point updates",
		"public:",
		"    int sz, neutral;",
		"    vector<int> seg;",
		"    function<int(int, int)> merge;",
		"",
		"    SGTree(int _sz, int _neutral, function<int(int, int)> _merge, const vector<int>& arr={}) {",
		"        sz=_sz; neutral=_neutral; merge=_merge; seg.resize(4*_sz+1);",
		"        if(!arr.empty()) this->build(arr);    ",
		"    }",
		"",
		"    //query, build and point updates",
		"    void build(const vector<int>& arr, int ind=0, int low=0, int high=-1){",
		"        if(high==-1) high=sz-1;",
		"        if(low==high){seg[ind]=arr[low];return;}",
		"",
		"        int mid=(low+high)>>1;",
		"        build(arr, 2*ind+1, low, mid); // build left subtree",
		"        build(arr, 2*ind+2, mid+1, high); // build right subtree",
		"        seg[ind]=merge(seg[2*ind+1],seg[2*ind+2]);",
		"    }",
		"",
		"    int query(int l, int r, int ind=0, int low=0, int high=-1){",
		"        if(high==-1) high=sz-1;",
		"        if(r<low || high<l) return neutral; // no overlap {l r low high} or {low high l r}",
		"        if(low>=l && high<=r) return seg[ind]; // complete overlap {l low high r}",
		"",
		"        int mid=(low+high)>>1; // partial overlap",
		"        int lTree=query(l, r, 2*ind+1, low, mid);",
		"        int rTree=query(l, r, 2*ind+2, mid+1, high);",
		"        return merge(lTree,rTree);",
		"    }",
		"",
		"    void update(int i, int val, int ind=0, int low=0, int high=-1){",
		"        if(high==-1) high=sz-1;",
		"        if(low==high) {seg[ind]=val; return;}",
		"",
		"        int mid=(low+high)>>1;",
		"        if(i<=mid){update(i, val, 2*ind+1, low, mid);}",
		"        else{update(i, val, 2*ind+2, mid+1, high);}",
		"        ",
		"        seg[ind]=merge(seg[2*ind+1],seg[2*ind+2]);",
		"    }",
		"};",
		"",
		],
		"description": "SGT"
	},
	"SGT2": {
		"prefix": "cp_SGT2",
		"body": [
		"class SGTree2{ // range updates",
		"public:",
		"    int sz;",
		"    vector<int> seg,lazy;",
		"    SGTree2(int n){sz=n; seg.resize(4*n+1); lazy.resize(4*n+1);}",
		"",
		"    //query, build and range updates",
		"    void build(vector<int>& arr, int ind=0, int low=0, int high=-1){",
		"        lazy[ind]=0; ",
		"        if(high==-1) high=sz-1;",
		"        if(low==high) {seg[ind]=arr[low]; return;}",
		"",
		"        int mid=(low+high)>>1;",
		"        build(arr, 2*ind+1, low, mid); // build left subtree",
		"        build(arr, 2*ind+2, mid+1, high); // build right subtree",
		"        seg[ind]=seg[2*ind+1]+seg[2*ind+2];",
		"    }",
		"",
		"    void update(int l, int r, int val, int ind=0, int low=0, int high=-1){",
		"        if(high==-1) high=sz-1;",
		"        ",
		"        if(lazy[ind]!=0){ // do remaining updates if any",
		"            seg[ind]+=(high-low+1)*lazy[ind];",
		"            if(low!=high){lazy[2*ind+1]+=lazy[ind]; lazy[2*ind+2]+=lazy[ind]; } // propagate updates if not a leaf node",
		"            lazy[ind]=0;",
		"        }",
		"",
		"        if(r<low || high<l) return; // no overlap {l r low high} or {low high l r}",
		"        if(low>=l && high<=r) { // complete overlap {l low high r}",
		"            seg[ind]+=(high-low+1)*val;",
		"            if(low!=high){lazy[2*ind+1]+=val; lazy[2*ind+2]+=val;}",
		"            return;    ",
		"        }",
		"",
		"        int mid = (low+high)>>1; // partial overlap",
		"        update(l, r, val, 2*ind+1, low, mid);",
		"        update(l, r, val, 2*ind+2, mid+1, high);",
		"        seg[ind]=seg[2*ind+1]+seg[2*ind+2];",
		"    }",
		"",
		"    int query(int l, int r, int ind=0, int low=0, int high=-1){",
		"        if(high==-1) high=sz-1;",
		"        ",
		"        if(lazy[ind]!=0){ // do remaining updates if any",
		"            seg[ind]+=(high-low+1)*lazy[ind];",
		"            if(low!=high){lazy[2*ind+1]+=lazy[ind]; lazy[2*ind+2]+=lazy[ind]; } // propagate updates if not a leaf node",
		"            lazy[ind]=0;",
		"        }",
		"",
		"        if(r<low || high<l) return 0; // no overlap {l r low high} or {low high l r}",
		"        if(low>=l && high<=r) return seg[ind]; // complete overlap {l low high r}",
		"",
		"        int mid=(low+high)>>1; // partial overlap",
		"        int lTree=query(l, r, 2*ind+1, low, mid);",
		"        int rTree=query(l, r, 2*ind+2, mid+1, high);",
		"        return lTree+rTree;",
		"    }",
		"};",
		""
		],
		"description": "SGT2"
	},
	"cp_BIT": {
		"prefix": "cp_BIT",
		"body": [
		"class FenwickTree{ // Binary Indexed Tree for pointUpdates",
		"public:",
		"    vector<int> tree; int sz; int neutral;",
		"    function<int(int, int)> merge;",
		"    function<int(int ,int)> inverseMerge;",
		"",
		"    FenwickTree(int _sz, int _neutral, function<int(int, int)> _merge, function<int(int, int)> _inverseMerge, const vector<int>& arr={}){",
		"        sz = _sz; neutral = _neutral; merge = _merge; inverseMerge = _inverseMerge;",
		"        tree.resize(sz+1, neutral);",
		"        if(!arr.empty()) this->build(arr);",
		"    }",
		"",
		"    void build(const vector<int>& arr={}){",
		"        for(int i=0; i<sz; i++){",
		"            update(i, arr[i]);",
		"        }",
		"    }",
		"",
		"    void update(int ind, int delta){",
		"        ind++;",
		"        for(; ind<=sz; ind+=(ind&(-ind))){",
		"            tree[ind] = merge(tree[ind], delta);",
		"        }",
		"    }",
		"",
		"    int prefixQuery(int ind){",
		"        ind++;",
		"        int result = neutral;",
		"        for(; ind>0; ind&=(ind-1)){",
		"            result = merge(result, tree[ind]);",
		"        }",
		"        return result;",
		"    }",
		"",
		"    int rangeQuery(int l, int r){",
		"        return inverseMerge(prefixQuery(r), prefixQuery(l-1));",
		"    }",
		"};"
		],
		"description": "cp_BIT"
	},
}